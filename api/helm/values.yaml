# Default values for api.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

config:
  # Onderstaande twee dingen samen trekken tot image  naar de lose container
  registryBase: docker.io/conduction
  projectName: proto-component-commonground
  name: proto-component-commonground # kan vervallen
  version: V1.0 # latest en imageTag
  majorVersion: v1 #kan weg 
  # domain en subdomain samentrekken en naar de ingres
  domain: conduction.nl #vervalt hier
  subdomain: proto-component-commonground #vervalt hier  
  subpath: proto-component-commonground # path in de ingres default op /
  subpathRouting: true # vervalt
  env: dev # vervallen
  web: false #vervalt
  debug: 1 #default false
  cache: false #default true
  id: # vervalt 
  internal: false # false
  replicaCount: 1 # naar de losse contianers
  corsAllowOrigin: ['*'] # naar de losse contianers
  trustedHosts: '^.+$' # naar de losse contianers
  pullPolicy: Always # naar de losse contianers
  # You will need these proxies on kubernetes
  trustedProxies: # naar de losse contianers
    - 10.0.0.0/8
    - 172.16.0.0/12
    - 192.168.0.0/16
  notificationEnabled: false <- service opgeeft
  audittrailEnabled: false  # vervallen
  authorisationEnabled: false <- service opgeeft
  healthEnabled: false  # vervallen
  archiveEnabled: false # vervallen

security:
  # uit elkaar trekken en refactor  
  applicationKey: "45c1a4b6-59d3-4a6e-86bf-88a872f35845"


php: 
  repository: docker.io/conduction/protocomponent-php
  tag: latest #imageTag
  mercure: #komt te vervallen
    jwtSecret: ""#komt te vervallen
  env: prod #komt te vervallen
  secret: "" #security
  replicaCount: 2

redis:
  cluster:
    enabled: false
  redisPort: 6379
  usePassword: false
  enabled: false

# komt te vervallen  
commonground:
  eherkenning:
    location: https://conduction.nl/eherkenning
  digispoof:
    location: https://conduction.nl/digispoof

# refactor conform afgesproken
nginx:
  repository: docker.io/conduction/protocomponent-nginx
  tag: latest
  pullPolicy: Always
  replicaCount: 2

postgresql:
  enabled: true #stretch goal koppelen aan url
  imageTag: 10-alpine
  # If bringing your own PostgreSQL, the full uri to use
  #url: pgsql://api-platform:!ChangeMe!@example.com/api?serverVersion=10.1
  postgresqlUsername: "example"
  postgresqlPassword: "!ChangeMe!"
  postgresqlDatabase: "api"
  # Persistent Volume Storage configuration.
  # ref: https://kubernetes.io/docs/user-guide/persistent-volumes
  persistence:
    enabled: true
  pullPolicy: IfNotPresent
#  image:
#    repository: postgres
#    tag: alpine

#vervalt
mercure:
  enabled: true
  publishUrl: http://mercure/hub
  subscribeUrl: https://mercure.example.com/hub
  allowAnonymous: "1"
  corsAllowedOrigins: "^https?://.*?\\.example\\.com$"
  acmeHosts: "" # TODO: Fix the Mercure chart
  service:
    type: NodePort
    port: 80

#kijk even naar de bitnami way
ingress:
  host: proto-component.local
  path: /api #moet / worden
  annotations:
    # kubernetes.io/ingress.global-static-ip-name: chart-ip
    # kubernetes.io/ingress.class: gce
    # kubernetes.io/tls-acme: "true"
  tls:
    # Secrets must be manually created in the namespace, you can also use cert-manager.
    # - hosts:
      # - example.com
      # - mercure.example.com
  hosts:
    api:
      host: example.com
      serviceName: varnish
    mercure:
      host: mercure.example.com
      serviceName: mercure

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi
